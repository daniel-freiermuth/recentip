#!/usr/bin/env python3
"""
Generate COMPLIANCE.md from requirements database and coverage annotations.

Reads:
  - spec-data/requirements.json (all spec requirements)
  - spec-data/coverage.json (generated by extract_coverage.py)

Generates:
  - COMPLIANCE.md (traceability matrix)
"""

import json
from pathlib import Path
from dataclasses import dataclass
from typing import Optional


@dataclass
class Requirement:
    """A spec requirement."""
    id: str
    reqtype: str
    source_file: str
    line_number: int
    text: str
    section: str
    status: str


def load_requirements(path: Path) -> dict[str, Requirement]:
    """Load requirements from JSON."""
    data = json.loads(path.read_text())
    return {
        r['id']: Requirement(**r)
        for r in data
    }


def load_coverage(path: Path) -> dict:
    """Load coverage data from JSON."""
    if not path.exists():
        return {"requirements_to_tests": {}, "tests": []}
    return json.loads(path.read_text())


def generate_compliance_md(
    requirements: dict[str, Requirement],
    coverage: dict,
    output_path: Path
):
    """Generate the COMPLIANCE.md file."""
    
    req_to_tests = coverage.get("requirements_to_tests", {})
    
    # Categorize requirements
    covered = []
    not_covered_reqs = []
    not_covered_info = []
    
    for req_id, req in sorted(requirements.items()):
        if req_id in req_to_tests:
            covered.append((req, req_to_tests[req_id]))
        elif req.reqtype == "Requirement":
            not_covered_reqs.append(req)
        else:
            not_covered_info.append(req)
    
    # Group by source file
    by_source = {}
    for req in requirements.values():
        if req.source_file not in by_source:
            by_source[req.source_file] = {"total": 0, "covered": 0, "info": 0}
        by_source[req.source_file]["total"] += 1
        if req.reqtype == "Information":
            by_source[req.source_file]["info"] += 1
        if req.id in req_to_tests:
            by_source[req.source_file]["covered"] += 1
    
    # Calculate coverage stats
    testable_count = sum(1 for r in requirements.values() if r.reqtype == 'Requirement')
    info_count = sum(1 for r in requirements.values() if r.reqtype == 'Information')
    covered_testable = sum(1 for req, _ in covered if req.reqtype == 'Requirement')
    covered_info = sum(1 for req, _ in covered if req.reqtype == 'Information')
    total_covered = covered_testable + covered_info
    coverage_pct = (covered_testable / testable_count * 100) if testable_count > 0 else 0
    
    # Generate markdown
    lines = [
        "# SOME/IP Specification Compliance",
        "",
        "This document provides traceability between the SOME/IP specification requirements",
        "and the compliance test suite. It is auto-generated by `scripts/generate_compliance.py`.",
        "",
        "## Summary",
        "",
        f"| Metric | Count |",
        f"|--------|-------|",
        f"| Total Requirements | {len(requirements)} |",
        f"| Requirements (testable) | {testable_count} |",
        f"| Information (non-testable) | {info_count} |",
        f"| Covered (testable) | {covered_testable} |",
        f"| Covered (info) | {covered_info} |",
        f"| **Total Covered** | **{total_covered}** |",
        f"| Not Yet Covered | {len(not_covered_reqs)} |",
        f"| **Coverage** | **{coverage_pct:.1f}%** |",
        "",
        "## Coverage by Spec Document",
        "",
        "| Document | Total | Covered | Info | Coverage % |",
        "|----------|-------|---------|------|------------|",
    ]
    
    for source, stats in sorted(by_source.items()):
        testable = stats["total"] - stats["info"]
        pct = (stats["covered"] / testable * 100) if testable > 0 else 0
        lines.append(
            f"| {source} | {stats['total']} | {stats['covered']} | {stats['info']} | {pct:.1f}% |"
        )
    
    lines.extend([
        "",
        "---",
        "",
        "## Covered Requirements",
        "",
        "Requirements with test coverage, grouped by spec document.",
        "",
    ])
    
    # Group covered requirements by source file
    covered_by_source: dict[str, list] = {}
    for req, tests in covered:
        if req.source_file not in covered_by_source:
            covered_by_source[req.source_file] = []
        covered_by_source[req.source_file].append((req, tests))
    
    for source in sorted(covered_by_source.keys()):
        lines.append(f"### {source}")
        lines.append("")
        lines.append("| Requirement | Tests | Description |")
        lines.append("|-------------|-------|-------------|")
        
        for req, tests in sorted(covered_by_source[source], key=lambda x: x[0].id):
            test_list = ", ".join(f"`{t}`" for t in tests[:3])
            if len(tests) > 3:
                test_list += f" (+{len(tests)-3} more)"
            # Truncate description
            desc = req.text[:80] + "..." if len(req.text) > 80 else req.text
            desc = desc.replace("|", "\\|").replace("\n", " ")
            lines.append(f"| `{req.id}` | {test_list} | {desc} |")
        
        lines.append("")
    
    lines.extend([
        "---",
        "",
        "## Not Yet Covered",
        "",
        "Requirements not yet covered by tests. Many of these may be:",
        "- Implementation details (covered implicitly)",
        "- Configuration requirements (not testable at runtime)",
        "- Optional features (deferred)",
        "",
    ])
    
    # Group not covered by source
    not_covered_by_source: dict[str, list] = {}
    for req in not_covered_reqs:
        if req.source_file not in not_covered_by_source:
            not_covered_by_source[req.source_file] = []
        not_covered_by_source[req.source_file].append(req)
    
    for source in sorted(not_covered_by_source.keys()):
        lines.append(f"### {source}")
        lines.append("")
        lines.append("<details>")
        lines.append(f"<summary>{len(not_covered_by_source[source])} requirements not covered</summary>")
        lines.append("")
        lines.append("| Requirement | Section | Description |")
        lines.append("|-------------|---------|-------------|")
        
        for req in sorted(not_covered_by_source[source], key=lambda x: x.id):
            desc = req.text[:60] + "..." if len(req.text) > 60 else req.text
            desc = desc.replace("|", "\\|").replace("\n", " ")
            section = req.section[:30] + "..." if len(req.section) > 30 else req.section
            lines.append(f"| `{req.id}` | {section} | {desc} |")
        
        lines.append("")
        lines.append("</details>")
        lines.append("")
    
    lines.extend([
        "---",
        "",
        "## Test Coverage Details",
        "",
        "All tests with `covers!()` annotations.",
        "",
        "| Test | File | Requirements | Status |",
        "|------|------|--------------|--------|",
    ])
    
    for test in sorted(coverage.get("tests", []), key=lambda t: t["test_name"]):
        reqs = ", ".join(f"`{r}`" for r in test["requirements"][:2])
        if len(test["requirements"]) > 2:
            reqs += f" (+{len(test['requirements'])-2})"
        status = "⏸️ Ignored" if test["is_ignored"] else "✅ Active"
        file_short = test["file_path"].split("/")[-1]
        lines.append(f"| `{test['test_name']}` | {file_short} | {reqs} | {status} |")
    
    lines.extend([
        "",
        "---",
        "",
        "*Generated by `scripts/generate_compliance.py`*",
    ])
    
    output_path.write_text("\n".join(lines))
    print(f"Generated: {output_path}")


def main():
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    
    requirements_path = project_root / "spec-data" / "requirements.json"
    coverage_path = project_root / "spec-data" / "coverage.json"
    output_path = project_root / "COMPLIANCE.md"
    
    if not requirements_path.exists():
        print(f"Error: Requirements not found: {requirements_path}")
        return 1
    
    requirements = load_requirements(requirements_path)
    coverage = load_coverage(coverage_path)
    
    generate_compliance_md(requirements, coverage, output_path)
    
    # Print summary
    req_to_tests = coverage.get("requirements_to_tests", {})
    print(f"\nCoverage: {len(req_to_tests)}/{len(requirements)} requirements ({len(req_to_tests)/len(requirements)*100:.1f}%)")
    
    return 0


if __name__ == "__main__":
    exit(main())
